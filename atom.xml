<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HXY</title>
  
  
  <link href="https://huxiuyuan/atom.xml" rel="self"/>
  
  <link href="https://huxiuyuan/"/>
  <updated>2022-03-24T10:13:33.442Z</updated>
  <id>https://huxiuyuan/</id>
  
  <author>
    <name>Hu XiuYuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6特性</title>
    <link href="https://huxiuyuan/2022/03/24/%E5%89%8D%E7%AB%AF/JavaScript/es6/"/>
    <id>https://huxiuyuan/2022/03/24/%E5%89%8D%E7%AB%AF/JavaScript/es6/</id>
    <published>2022-03-24T10:10:28.914Z</published>
    <updated>2022-03-24T10:13:33.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><blockquote><p>ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。</p></blockquote><h2 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>let 声明的变量只在 let 命令所在的代码块内有效。</li><li>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</li></ul><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li><p>let 是在代码块中有效， var 是全局有效</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a  <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">b  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>不能重复声明</p><ul><li>let 只能声明一次</li><li>var可以声明多次</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">a <span class="comment">// Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line">b <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="for循环计数器适合用-let"><a href="#for循环计数器适合用-let" class="headerlink" title="for循环计数器适合用 let"></a>for循环计数器适合用 let</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="comment">// 结果：输出十个 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="comment">// 结果：输出0123456789</span></span><br></pre></td></tr></table></figure><ul><li>变量 i 是用 var 声明的，在全局范围内只有一个变量 i ，每次循环时，setTimeout里面的 i 指的是全局变量 i ，所以循环里的十个 setTimeout 是在循环结束后才执行，所以此时的 i 都是 10.</li><li>变量 j 是用 let 声明的，当前的 j 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量。（若每次循环的变量 j 都是重新声明的，如何知道前一个循环的值？这是因为 JavaScript 引擎内部会记住前一个循环的值）</li></ul><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><ul><li><p>let 不存在变量提升，var 会变量提升</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cosole.log(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&quot;banana&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>变量 b 用 var 声明存在变量提升，所以当脚本开始运行时，b 就已经存在了，但是还没有赋值，所以是 undefined。</p></li><li><p>变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。</p></li></ul><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><ul><li>const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。</li></ul><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line">PI  <span class="comment">// 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MY_AGE;  <span class="comment">//SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var PI = &quot;a&quot;;</span><br><span class="line">if(true) &#123;</span><br><span class="line">console.log(PI);  // ReferenceError: PI is not defined</span><br><span class="line">    const PI = &quot;3.1415926&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ES6 明确规定，代码块内如果存在 let 或 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。所以，代码块内，在声明变量 PI 之前使用它会报错。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。</li><li>对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。</li><li>而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了</li></ul><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>解构赋值是对赋值运算符的扩展。</li><li>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</li><li>代码简洁易读，语义清晰，方便了复杂对象中数据字段获取。</li></ul><h3 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h3><ul><li>解构的源：解构赋值表达式的右边部分。</li><li>结构的目标：表达式左边的部分。</li></ul><h3 id="数组模型的结构（Array）"><a href="#数组模型的结构（Array）" class="headerlink" title="数组模型的结构（Array）"></a>数组模型的结构（Array）</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1, b = 2, c = 3</span></span><br></pre></td></tr></table></figure><h4 id="可嵌套"><a href="#可嵌套" class="headerlink" title="可嵌套"></a>可嵌套</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b],c] ] = [<span class="number">1</span>, [[<span class="number">2</span>],<span class="number">3</span>] ];</span><br><span class="line"><span class="comment">// a = 1, b = 2, c = 3</span></span><br></pre></td></tr></table></figure><h4 id="可忽略"><a href="#可忽略" class="headerlink" title="可忽略"></a>可忽略</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1, b = 3</span></span><br></pre></td></tr></table></figure><h4 id="不完全解构"><a href="#不完全解构" class="headerlink" title="不完全解构"></a>不完全解构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = [];</span><br><span class="line"><span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure><h4 id="剩余运算符-…"><a href="#剩余运算符-…" class="headerlink" title="剩余运算符 …"></a>剩余运算符 …</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1, b = [2,3]</span></span><br></pre></td></tr></table></figure><h4 id="字符串等"><a href="#字符串等" class="headerlink" title="字符串等"></a>字符串等</h4><ul><li>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 iterator 接口的数据。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c,d,e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">// a = &#x27;h&#x27;, b = &#x27;e&#x27;, c = &#x27;l&#x27;, d = &#x27;l&#x27;, e = &#x27;o&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="解构默认值"><a href="#解构默认值" class="headerlink" title="解构默认值"></a>解构默认值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>];</span><br><span class="line"><span class="comment">// a = 2</span></span><br></pre></td></tr></table></figure><ul><li>当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br></pre></td></tr></table></figure><ul><li>a 与 b 匹配结果为 undefined ，触发默认值：a = 3; b = a =3</li><li>a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a = 1</li><li>a 与 b 正常解构赋值，匹配结果：a = 1，b = 2</li></ul><h3 id="对象模型的解构"><a href="#对象模型的解构" class="headerlink" title="对象模型的解构"></a>对象模型的解构</h3><h4 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo, bar&#125; = &#123;<span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;aaa&#x27;, bar = &#x27;bbb&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">baz</span> : foo&#125; = &#123;<span class="attr">baz</span> : <span class="string">&#x27;ddd&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// foo = &#x27;ddd&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="可嵌套可忽略"><a href="#可嵌套可忽略" class="headerlink" title="可嵌套可忽略"></a>可嵌套可忽略</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123;y&#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="不完全解构-1"><a href="#不完全解构-1" class="headerlink" title="不完全解构"></a>不完全解构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>:[&#123;y&#125;,x] &#125; = obj;</span><br><span class="line"><span class="comment">// x = undefined</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="剩余运算符"><a href="#剩余运算符" class="headerlink" title="剩余运算符"></a>剩余运算符</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;;</span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br><span class="line"><span class="comment">// c = &#123;c: 30, d :40&#125;</span></span><br></pre></td></tr></table></figure><h4 id="解构默认值-1"><a href="#解构默认值-1" class="headerlink" title="解构默认值"></a>解构默认值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ECMAScript 6.0特性</summary>
    
    
    
    <category term="前端" scheme="https://huxiuyuan/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://huxiuyuan/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装</title>
    <link href="https://huxiuyuan/2022/03/21/Docker/Centos7%E5%AE%89%E8%A3%85Docker/"/>
    <id>https://huxiuyuan/2022/03/21/Docker/Centos7%E5%AE%89%E8%A3%85Docker/</id>
    <published>2022-03-21T13:39:19.696Z</published>
    <updated>2022-03-22T12:47:51.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0-安装Docker"><a href="#0-安装Docker" class="headerlink" title="0.安装Docker"></a>0.安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>通过命令启动docker：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure><p>然后输入命令，可以查看docker版本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/huxiuyuan/java-learn/202202241511021.png" alt="image-20220224151127911"></p><h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p><p><img src="assets/image-20210417133020614.png" alt="image-20210417133020614"></p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 补全命令</span></span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2.带有图形化界面版本"></a>3.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=传智教育私有仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></table></figure><h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3.配置Docker信任地址"></a>3.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux安装Docker</summary>
    
    
    
    <category term="Docker" scheme="https://huxiuyuan/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://huxiuyuan/2022/03/20/Docker/docker/"/>
    <id>https://huxiuyuan/2022/03/20/Docker/docker/</id>
    <published>2022-03-19T19:41:06.953Z</published>
    <updated>2022-03-22T12:48:01.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote><p>Docker是一个快速交付应用、运行应用的技术</p></blockquote><p>项目部署的问题</p><p>大型项目组件较多，运行环境也较为复杂，部署时会遇到一些问题：</p><ul><li>依赖关系复杂，容易出现兼容性问题</li><li>开发，测试，生产环境有差异</li></ul><h2 id="Docker如何解决依赖的兼容性问题？"><a href="#Docker如何解决依赖的兼容性问题？" class="headerlink" title="Docker如何解决依赖的兼容性问题？"></a>Docker如何解决依赖的兼容性问题？</h2><ul><li>Ubuntn和CentOS都是基于Liunx内核，只是系统应用不同，提供的函数库有差异</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huxiuyuan/java-learn/202112242102916.png" alt="image-20211224210226739"></p><blockquote><ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntn)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的库函数，借助于操作系统的Linux内核来运行</li></ul></blockquote><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><h2 id="Docker与虚拟机"><a href="#Docker与虚拟机" class="headerlink" title="Docker与虚拟机"></a>Docker与虚拟机</h2><p><img src="https://cdn.jsdelivr.net/gh/huxiuyuan/java-learn/202112242113120.png" alt="image-20211224211342994"></p><p>Docker和虚拟机的差异：</p><blockquote><ul><li>docker是一个系统进程，虚拟机是在操作系统中的操作系统。</li><li>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般。</li></ul></blockquote><h2 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h2><blockquote><p>镜像（image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，成为镜像。</p><p>容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只    是Docker会给容器做隔离，对外不可见</p></blockquote><h2 id="Docker和DockerHub"><a href="#Docker和DockerHub" class="headerlink" title="Docker和DockerHub"></a>Docker和DockerHub</h2><ul><li>DockerHub：DockerHub是一个Docker镜像的托管平台。这样的平台称为Docker Registry。</li><li>国内也有类似于DockerHub的公开服务，比如网易云镜像服务、阿里云镜像服务</li></ul><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><ul><li><p>Docker是一个CS架构的程序，由两部分组成：</p><ol><li><p>服务端（server）：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端（client）：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p><p><img src="https://cdn.jsdelivr.net/gh/huxiuyuan/java-learn/202112242125466.png" alt="image-20211224212532354"></p></li></ol></li></ul><h2 id="Docker数据卷"><a href="#Docker数据卷" class="headerlink" title="Docker数据卷"></a>Docker数据卷</h2><ul><li><blockquote><p>数据卷（volume）：是一个虚拟目录，指向宿主机文件系统中的某个目录</p></blockquote></li></ul><p>docker容器内部配置对外不可见，容器删除后配置随之删除，造成了</p><ol><li>不便于修改，要进入容器内部进行修改</li><li>数据不可复用：在容器内的修改对外是不可见的。所有修改对新创建的容器不可复用</li><li>升级维护困难：数据在容器内，如果要升级容器必然删除旧容器，所有数据都跟着删除了</li></ol><p><img src="https://cdn.jsdelivr.net/gh/huxiuyuan/java-learn/202112271509737.png" alt="image-20211227150906606"></p><ul><li>数据卷的作用<ol><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ol></li></ul><h2 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h2><p>我们在创建容器时，可以通过 -v 参数来挂在一个数据卷到某个容器目录</p><p><img src="https://cdn.jsdelivr.net/gh/huxiuyuan/java-learn/202112271517486.png" alt="image-20211227151759434"></p>]]></content>
    
    
    <summary type="html">Docker介绍</summary>
    
    
    
    <category term="Docker" scheme="https://huxiuyuan/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://huxiuyuan/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://huxiuyuan/2022/03/19/hexo/hello-world/"/>
    <id>https://huxiuyuan/2022/03/19/hexo/hello-world/</id>
    <published>2022-03-18T17:34:43.135Z</published>
    <updated>2022-03-22T12:46:03.008Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动Hexo本地服务"><a href="#启动Hexo本地服务" class="headerlink" title="启动Hexo本地服务"></a>启动Hexo本地服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">访问localhost:4000访问本地服务</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="将博客推送到github上"><a href="#将博客推送到github上" class="headerlink" title="将博客推送到github上"></a>将博客推送到github上</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">Hexo 基本命令</summary>
    
    
    
    <category term="Hexo" scheme="https://huxiuyuan/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
